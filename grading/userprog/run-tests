#! /usr/bin/perl

use warnings;
use strict;
use POSIX;
use Algorithm::Diff;
use Getopt::Long;

our ($VERBOSE) = 0;	# Verbosity of output
our (@TESTS);		# Tests to run.
my ($clean) = 0;
my ($grade) = 0;

GetOptions ("v|verbose+" => \$VERBOSE,
	    "h|help" => sub { usage (0) },
	    "t|test=s" => \@TESTS,
	    "c|clean" => \$clean,
	    "g|grade" => \$grade)
    or die "Malformed command line; use --help for help.\n";
die "Non-option argument not supported; use --help for help.\n"
    if @ARGV > 0;

sub usage {
    my ($exitcode) = @_;
    print "run-tests, for grading Pintos multiprogramming projects.\n\n";
    print "Invoke from a directory containing a student tarball named by\n";
    print "the submit script, e.g. username.Oct.12.04.20.04.09.tar.gz.\n";
    print "In normal usage, no options are needed.\n\n";
    print "Output is produced in tests.out and details.out.\n\n";
    print "Options:\n";
    print "  -c, --clean     Remove old output files before starting\n";
    print "  -t, --test=TEST Execute TEST only (allowed multiple times)\n";
    print "  -g, --grade     Instead of running tests, compose grade.out\n";
    print "  -v, --verbose   Print commands before executing them\n";
    print "  -h, --help      Print this help message\n";
    exit $exitcode;
}

# Default set of tests.
@TESTS = qw (args-argc args-argv0 args-argvn args-single args-multiple
	     args-dbl-space
	     sc-bad-sp sc-bad-arg sc-boundary
	     halt exit
	     create-normal create-empty create-null create-bad-ptr
	     create-long create-exists create-bound
	     open-normal open-missing open-boundary open-empty open-null
	     open-bad-ptr open-twice
	     close-normal close-twice close-stdin close-stdout close-bad-fd
	     read-normal read-bad-ptr read-boundary read-zero read-stdout
	     read-bad-fd
	     write-normal write-bad-ptr write-boundary write-zero write-stdin
	     write-bad-fd
	     exec-once exec-arg exec-multiple exec-missing exec-bad-ptr
	     ) unless @TESTS > 0;

our (%args);
for my $key ('args-argc', 'args-argv0', 'args-argvn', 'args-multiple') {
    $args{$key} = "some arguments for you!";
}
$args{'args-single'} = "onearg";
$args{'args-dbl-space'} = "two  args";

# Handle final grade mode.
if ($grade) {
    open (OUT, ">grade.out") or die "grade.out: create: $!\n";

    open (GRADE, "<grade.txt") or die "grade.txt: open: $!\n";
    while (<GRADE>) {
	last if /^\s*$/;
	print OUT;
    }
    close (GRADE);

    my (@tests) = snarf ("tests.out");
    my ($p_got, $p_pos) = $tests[0] =~ m%\((\d+)/(\d+)\)% or die;

    my (@review) = snarf ("review.txt");
    my ($part_lost) = (0, 0);
    for (my ($i) = $#review; $i >= 0; $i--) {
	local ($_) = $review[$i];
	if (my ($loss) = /^\s*([-+]\d+)/) {
	    $part_lost += $loss;
	} elsif (my ($out_of) = m%\[\[/(\d+)\]\]%) {
	    my ($got) = $out_of + $part_lost;
	    $got = 0 if $got < 0;
	    $review[$i] =~ s%\[\[/\d+\]\]%($got/$out_of)% or die;
	    $part_lost = 0;

	    $p_got += $got;
	    $p_pos += $out_of;
	}
    }
    die "Lost points outside a section\n" if $part_lost;

    for (my ($i) = 1; $i <= $#review; $i++) {
	if ($review[$i] =~ /^-{3,}\s*$/ && $review[$i - 1] !~ /^\s*$/) {
	    $review[$i] = '-' x (length ($review[$i - 1]));
	}
    }

    print OUT "\nOVERALL SCORE\n";
    print OUT "-------------\n";
    print OUT "$p_got points out of $p_pos total\n\n";

    print OUT map ("$_\n", @tests), "\n";
    print OUT map ("$_\n", @review), "\n";

    print OUT "DETAILS\n";
    print OUT "-------\n\n";
    print OUT map ("$_\n", snarf ("details.out"));

    exit 0;
}

# Find the directory that contains the grading files.
our ($GRADES_DIR);
($GRADES_DIR = $0) =~ s#/[^/]+$##;
-d $GRADES_DIR or die "$GRADES_DIR: stat: $!\n";

if ($clean) {
    # Verify that we're roughly in the correct directory
    # before we go blasting away files.
    choose_tarball ();

    xsystem ("rm -rf output pintos", VERBOSE => 1);
    xsystem ("rm -f details.out tests.out", VERBOSE => 1);
}

# Create output directory, if it doesn't already exist.
-d ("output") || mkdir ("output") or die "output: mkdir: $!\n";

# Extract submission.
extract_tarball () if ! -d "pintos";

# Compile submission.
compile ();

# Verify that the proper directory was submitted.
-d "pintos/src/threads" or die "pintos/src/threads: stat: $!\n";

# Run and grade the tests.
our $test;
our %result;
our %details;
our %extra;
for $test (@TESTS) {
    print "$test: ";
    my ($result) = run_test ($test);
    if ($result eq 'ok') {
	$result = grade_test ($test);
	$result =~ s/\n$//;
    }
    print "$result";
    print " - with warnings" if $result eq 'ok' && defined $details{$test};
    print "\n";

    $result{$test} = $result;
}

# Write output.
write_grades ();
write_details ();

sub choose_tarball {
    my (@tarballs)
	= grep (/^[a-z0-9]+\.[A-Za-z]+\.\d+\.\d+\.\d+\.\d+.\d+\.tar\.gz$/,
		glob ("*.tar.gz"));
    die "no pintos dir and no source tarball\n" if scalar (@tarballs) == 0;

    # Sort tarballs in reverse order by time.
    @tarballs = sort { ext_mdyHMS ($b) cmp ext_mdyHMS ($a) } @tarballs;

    print "Multiple tarballs: choosing $tarballs[0]\n"
	if scalar (@tarballs) > 1;
    return $tarballs[0];
}

sub extract_tarball {
    my ($tarball) = choose_tarball ();

    mkdir "pintos" or die "pintos: mkdir: $!\n";
    mkdir "pintos/src" or die "pintos: mkdir: $!\n";

    print "Extracting $tarball...\n";
    xsystem ("cd pintos/src && tar xzf ../../$tarball",
	     DIE => "extraction failed\n");

    print "Patching...\n";
    xsystem ("patch -fs pintos/src/lib/debug.c < $GRADES_DIR/panic.diff",
	     LOG => "patch",
	     DIE => "patch failed\n");
}

sub ext_mdyHMS {
    my ($s) = @_;
    my ($ms, $d, $y, $H, $M, $S) =
	$s =~ /.([A-Za-z]+)\.(\d+)\.(\d+)\.(\d+)\.(\d+).(\d+)\.tar\.gz$/
	or die;
    my ($m) = index ("janfebmaraprmayjunjulaugsepoctnovdec", lc $ms) / 3
	or die;
    return sprintf "%02d-%02d-%02d %02d:%02d:%02d", $y, $m, $d, $H, $M, $S;
}

sub test_source {
    my ($test) = @_;
    my ($src) = "$GRADES_DIR/$test.c";
    -e $src or die "$src: stat: $!\n";
    return $src;
}

sub test_constants {
   my ($defines) = "";
   return $defines;
 }

sub run_test {
    my ($test) = @_;

    # Reuse older results if any.
    if (open (DONE, "<output/$test/done")) {
	my ($status);
	$status = <DONE>;
	chomp $status;
	close (DONE);
	return $status;
    }

    # Really run the test.
    my ($status) = really_run_test ($test);

    # Save the results for later.
    open (DONE, ">output/$test/done") or die "output/$test/done: create: $!\n";
    print DONE "$status\n";
    close (DONE);

    return $status;
}

sub compile {
    print "Compiling...\n";
    xsystem ("cd pintos/src/userprog && make", LOG => "make")
	or return "compile error";
}

sub really_run_test {
    # Need to run it.
    # If there's residue from an earlier test, move it to .old.
    # If there's already a .old, delete it.
    xsystem ("rm -rf output/$test.old", VERBOSE => 1) if -d "output/$test.old";
    rename "output/$test", "output/$test.old" or die "rename: $!\n"
	if -d "output/$test";

    # Make output directory.
    mkdir "output/$test";
    xsystem ("cp $GRADES_DIR/$test.dsk output/$test/fs.dsk",
	     DIE => "cp failed\n");

    # Run.
    my ($timeout) = 10;
    my ($testargs) = defined ($args{$test}) ? " $args{$test}" : "";
    xsystem ("pintos "
	     . "--os-disk=pintos/src/userprog/build/os.dsk "
	     . "--fs-disk=output/$test/fs.dsk "
	     . "-v run -q -ex \"$test$testargs\"",
	     LOG => "$test/run",
	     TIMEOUT => $timeout)
	or return "Bochs error";

    return "ok";
}

sub grade_test {
    my ($test) = @_;

    my (@output) = snarf ("output/$test/run.out");

    my ($grade_func) = "grade_$test";
    $grade_func =~ s/-/_/g;
    if (-e "$GRADES_DIR/$test.exp" && !defined (&$grade_func)) {
	eval {
	    verify_common (@output);
	    compare_output ("$GRADES_DIR/$test.exp", @output);
	}
    } else {
	eval "$grade_func (\@output)";
    }
    if ($@) {
	die $@ if $@ =~ /at \S+ line \d+$/;
	return $@;
    }
    return "ok";
}

sub grade_write_normal {
    my (@output) = @_;
    verify_common (@output);
    compare_output ("$GRADES_DIR/write-normal.exp", @output);
    my ($test_txt) = "output/$test/test.txt";
    get_file ("test.txt", $test_txt) if ! -e $test_txt;

    my (@actual) = snarf ($test_txt);
    my (@expected) = snarf ("$GRADES_DIR/sample.txt");

    my ($eq);
    if ($#actual == $#expected) {
	$eq = 1;
	for my $i (0...$#actual) {
	    $eq = 0 if $actual[$i] ne $expected[$i];
	}
    } else {
	$eq = 0;
    }
    if (!$eq) {
	my ($details);
	$details = "Expected file content:\n";
	$details .= join ('', map ("  $_\n", @expected));
	$details .= "Actual file content:\n";
	$details .= join ('', map ("  $_\n", @actual));
	$extra{$test} = $details;

	die "File written didn't have expected content.\n";
    }
}

sub get_file {
    my ($guest_fn, $host_fn) = @_;
    xsystem ("pintos "
	     . "--os-disk=pintos/src/userprog/build/os.dsk "
	     . "--fs-disk=output/$test/fs.dsk "
	     . "-v get $guest_fn $host_fn",
	     LOG => "$test/get-$guest_fn",
	     TIMEOUT => 10)
	or die "get $guest_fn failed\n";
}

sub grade_alarm_negative {
    my (@output) = @_;
    verify_common (@output);
    die "Crashed in timer_sleep()\n" if !grep (/^Success\.$/, @output);
}

sub grade_join_invalid {
    my (@output) = @_;
    verify_common (@output);
    grep (/Testing invalid join/, @output) or die "Test didn't start\n";
    grep (/Invalid join test done/, @output) or die "Test didn't complete\n";
}

sub grade_join_no {
    my (@output) = @_;
    verify_common (@output);
    grep (/Testing no join/, @output) or die "Test didn't start\n";
    grep (/No join test done/, @output) or die "Test didn't complete\n";
}

sub grade_join_multiple {
    my (@output) = @_;

    verify_common (@output);
    my (@t);
    $t[4] = $t[5] = $t[6] = -1;
    local ($_);
    foreach (@output) {
	my ($idx) = /^Thread (\d+)/ or next;
	my ($iter) = /iteration (\d+)$/;
	$iter = 5 if /done!$/;
	die "Malformed output\n" if !defined $iter;
	if ($idx == 6) {
	    die "Thread 6 started before either other thread finished\n"
		if $t[4] < 5 && $t[5] < 5;
	    die "Thread 6 started before thread 4 finished\n"
		if $t[4] < 5;
	    die "Thread 6 started before thread 5 finished\n"
		if $t[5] < 5;
	}
	die "Thread $idx out of order output\n" if $t[$idx] != $iter - 1;
	$t[$idx] = $iter;
    }

    my ($err) = "";
    for my $idx (4, 5, 6) {
	if ($t[$idx] == -1) {
	    $err .= "Thread $idx did not run at all\n";
	} elsif ($t[$idx] != 5) {
	    $err .= "Thread $idx only completed $t[$idx] iterations\n";
	}
    }
    die $err if $err ne '';
}

sub grade_priority_fifo {
    my (@output) = @_;

    verify_common (@output);
    my ($thread_cnt) = 10;
    my ($iter_cnt) = 5;
    my (@order);
    my (@t) = (-1) x $thread_cnt;
    local ($_);
    foreach (@output) {
	my ($idx) = /^Thread (\d+)/ or next;
	my ($iter) = /iteration (\d+)$/;
	$iter = $iter_cnt if /done!$/;
	die "Malformed output\n" if !defined $iter;
	if (@order < $thread_cnt) {
	    push (@order, $idx);
	    die "Thread $idx repeated within first $thread_cnt iterations: "
		. join (' ', @order) . ".\n"
		if grep ($_ == $idx, @order) != 1;
	} else {
	    die "Thread $idx ran when $order[0] should have.\n"
		if $idx != $order[0];
	    push (@order, shift @order);
	}
	die "Thread $idx out of order output.\n" if $t[$idx] != $iter - 1;
	$t[$idx] = $iter;
    }

    my ($err) = "";
    for my $idx (0..$#t) {
	if ($t[$idx] == -1) {
	    $err .= "Thread $idx did not run at all.\n";
	} elsif ($t[$idx] != $iter_cnt) {
	    $err .= "Thread $idx only completed $t[$idx] iterations.\n";
	}
    }
    die $err if $err ne '';
}

sub grade_mlfqs_on {
    my (@output) = @_;
    verify_common (@output);
    our (@mlfqs_on_stats) = mlfqs_stats (@output);
}

sub grade_mlfqs_off {
    my (@output) = @_;
    verify_common (@output);
    our (@mlfqs_off_stats) = mlfqs_stats (@output);
}

sub grade_mlfqs_speedup {
    our (@mlfqs_off_stats);
    our (@mlfqs_on_stats);
    eval {
	check_mlfqs ();
	my ($off_ticks) = $mlfqs_off_stats[1];
	my ($on_ticks) = $mlfqs_on_stats[1];
	die "$off_ticks ticks without MLFQS, $on_ticks with MLFQS\n"
	    if $on_ticks >= $off_ticks;
	die "ok\n";
    };
    chomp $@;
    $result{'mlfqs-speedup'} = $@;
}

sub grade_mlfqs_priority {
    our (@mlfqs_off_stats);
    our (@mlfqs_on_stats);
    eval {
	check_mlfqs () if !defined (@mlfqs_on_stats);
	for my $cat qw (CPU IO MIX) {
	    die "Priority changed away from PRI_DEFAULT (29) without MLFQS\n"
		if $mlfqs_off_stats[0]{$cat}{MIN} != 29
		|| $mlfqs_off_stats[0]{$cat}{MAX} != 29;
	    die "Minimum priority never changed from PRI_DEFAULT (29) "
		. "with MLFQS\n"
		if $mlfqs_on_stats[0]{$cat}{MIN} == 29;
	    die "Maximum priority never changed from PRI_DEFAULT (29) "
		. "with MLFQS\n"
		if $mlfqs_on_stats[0]{$cat}{MAX} == 29;
	}
	die "ok\n";
    };
    chomp $@;
    $result{'mlfqs-priority'} = $@;
}

sub check_mlfqs {
    our (@mlfqs_off_stats);
    our (@mlfqs_on_stats);
    die "p1-4 didn't finish with MLFQS on or off\n"
	if !defined (@mlfqs_off_stats) && !defined (@mlfqs_on_stats);
    die "p1-4 didn't finish with MLFQS on\n"
	if !defined (@mlfqs_on_stats);
    die "p1-4 didn't finish with MLFQS off\n"
	if !defined (@mlfqs_off_stats);
}

sub mlfqs_stats {
    my (@output) = @_;
    my (%stats) = (CPU => {}, IO => {}, MIX => {});
    my (%map) = ("CPU intensive" => 'CPU',
		 "IO intensive" => 'IO',
		 "Alternating IO/CPU" => 'MIX');
    my (%rmap) = reverse %map;
    my ($ticks);
    local ($_);
    foreach (@output) {
	$ticks = $1 if /Timer: (\d+) ticks/;
	my ($thread, $pri) = /^([A-Za-z\/ ]+): (\d+)$/ or next;
	my ($t) = $map{$thread} or next;

	my ($s) = $stats{$t};
	$$s{N}++;
	$$s{SUM} += $pri;
	$$s{SUM2} += $pri * $pri;
	$$s{MIN} = $pri if !defined ($$s{MIN}) || $pri < $$s{MIN};
	$$s{MAX} = $pri if !defined ($$s{MAX}) || $pri > $$s{MAX};
    }

    my (%expect_n) = (CPU => 5000, IO => 1000, MIX => 12000);
    for my $cat (values (%map)) {
	my ($s) = $stats{$cat};
	die "$rmap{$cat} printed $$s{N} times, not $expect_n{$cat}\n"
	    if $$s{N} != $expect_n{$cat};
	die "$rmap{$cat} priority dropped to $$s{MIN}, below PRI_MIN (0)\n"
	    if $$s{MIN} < 0;
	die "$rmap{$cat} priority rose to $$s{MAX}, above PRI_MAX (59)\n"
	    if $$s{MAX} > 59;
	$$s{MEAN} = $$s{SUM} / $$s{N};
    }

    return (\%stats, $ticks);
}

sub verify_common {
    my (@output) = @_;

    my (@assertion) = grep (/PANIC/, @output);
    if (@assertion != 0) {
	my ($details) = "Kernel panic:\n  $assertion[0]\n";

	my (@stack_line) = grep (/Call stack:/, @output);
	if (@stack_line != 0) {
	    $details .= "  $stack_line[0]\n\n";
	    $details .= "Translation of backtrace:\n";
	    my (@addrs) = $stack_line[0] =~ /Call stack:((?: 0x[0-9a-f]+)+)/;

	    my ($A2L);
	    if (`uname -m`
		=~ /i.86|pentium.*|[pk][56]|nexgen|viac3|6x86|athlon.*/) {
		$A2L = "addr2line";
	    } else {
		$A2L = "i386-elf-addr2line";
	    }
	    open (A2L, "$A2L -fe output/$test/kernel.o @addrs|");
	    for (;;) {
		my ($function, $line);
		last unless defined ($function = <A2L>);
		$line = <A2L>;
		chomp $function;
		chomp $line;
		$details .= "  $function ($line)\n";
	    }
	}
	$extra{$test} = $details;
	die "Kernel panic.  Details at end of file.\n"
    }

    die "No output at all\n" if @output == 0;
    die "Didn't start up properly: no \"Pintos booting\" startup message\n"
	if !grep (/Pintos booting with.*kB RAM\.\.\./, @output);
    die "Didn't start up properly: no \"Boot complete\" startup message\n"
	if !grep (/Boot complete/, @output);
    die "Didn't shut down properly: no \"Timer: # ticks\" shutdown message\n"
        if !grep (/Timer: \d+ ticks/, @output);
    die "Didn't shut down properly: no \"Powering off\" shutdown message\n"
	if !grep (/Powering off/, @output);
}

# Get @output without header or trailer.
sub get_core_output {
    my (@output) = @_;

    our ($test);
    my ($first);
    for ($first = 0; $first <= $#output; $first++) {
	$first++, last if $output[$first] =~ /^Executing '$test.*':$/;
    }

    my ($last);
    for ($last = $#output; $last >= 0; $last--) {
	$last--, last if $output[$last] =~ /^Timer: \d+ ticks$/;
    }

    if ($last < $first) {
	my ($no_first) = $first > $#output;
	my ($no_last) = $last < $#output;
	die "Couldn't locate output.\n";
    }

    return @output[$first ... $last];
}

sub compare_output {
    my ($exp, @actual) = @_;
    @actual = get_core_output (map ("$_\n", @actual));

    # Fix up lines that look like exit codes.
    for my $i (0...$#actual) {
	if (my ($process, $code)
	    = $actual[$i] =~ /^([-a-zA-Z0-9 ]+):.*[ \(](-?\d+)\b\)?$/) {
	    $process = substr ($process, 0, 15);
	    $process =~ s/\s.*//;
	    $actual[$i] = "$process: exit($code)\n";
	}
    }

    my ($details) = "";
    $details .= "$test actual output:\n";
    $details .= join ('', map ("  $_", @actual));

    my (@exp) = map ("$_\n", snarf ($exp));

    my ($fuzzy_match) = 0;
    while (@exp != 0) {
	my (@expected);
	while (@exp != 0) {
	    my ($s) = shift (@exp);
	    last if $s eq "--OR--\n";
	    push (@expected, $s);
	}

	$details .= "\n$test acceptable output:\n";
	$details .= join ('', map ("  $_", @expected));

	# Check whether they're the same.
	if ($#actual == $#expected) {
	    my ($eq) = 1;
	    for (my ($i) = 0; $i <= $#expected; $i++) {
		$eq = 0 if $actual[$i] ne $expected[$i];
	    }
	    return if $eq;
	}

	# They differ.  Output a diff.
	my (@diff) = "";
	my ($d) = Algorithm::Diff->new (\@expected, \@actual);
	my ($not_fuzzy_match) = 0;
	while ($d->Next ()) {
	    my ($ef, $el, $af, $al) = $d->Get (qw (min1 max1 min2 max2));
	    if ($d->Same ()) {
		push (@diff, map ("  $_", $d->Items (1)));
	    } else {
		push (@diff, map ("- $_", $d->Items (1))) if $d->Items (1);
		push (@diff, map ("+ $_", $d->Items (2))) if $d->Items (2);
		if ($d->Items (1)
		    || grep (/\($test\)|exit\(-?\d+\)/, $d->Items (2))) {
		    $not_fuzzy_match = 1;
		}
	    }
	}
	$fuzzy_match = 1 if !$not_fuzzy_match;

	$details .= "Differences in `diff -u' format:\n";
	$details .= join ('', @diff);
	$details .= "(This is considered a `fuzzy match'.)\n" if $fuzzy_match;
    }

    $details{$test} = $details;
    die "Output differs from expected.  Details at end of file.\n"
	unless $fuzzy_match;
}

sub write_grades {
    my (@summary) = snarf ("$GRADES_DIR/tests.txt");

    my ($ploss) = 0;
    my ($tloss) = 0;
    my ($total) = 0;
    for (my ($i) = 0; $i <= $#summary; $i++) {
	local ($_) = $summary[$i];
	if (my ($loss, $test) = /^  -(\d+) ([-a-zA-Z0-9]+):/) {
	    my ($result) = $result{$test} || "Not tested.";

	    if ($result eq 'ok') {
		splice (@summary, $i, 1);
		$i--;
	    } else {
		$ploss += $loss;
		$tloss += $loss;
		splice (@summary, $i + 1, 0,
			map ("     $_", split ("\n", $result)));
	    }
	} elsif (my ($ptotal) = /^Score: \/(\d+)$/) {
	    $total += $ptotal;
	    $summary[$i] = "Score: " . ($ptotal - $ploss) . "/$ptotal";
	    splice (@summary, $i, 0, "  All tests passed.") if $ploss == 0;
	    $ploss = 0;
	    $i++;
	}
    }
    my ($ts) = "(" . ($total - $tloss) . "/" . $total . ")";
    $summary[0] =~ s/\[\[total\]\]/$ts/;

    open (SUMMARY, ">tests.out");
    print SUMMARY map ("$_\n", @summary);
    close (SUMMARY);
}

sub write_details {
    open (DETAILS, ">details.out");
    my ($n) = 0;
    for my $test (@TESTS) {
	next if $result{$test} eq 'ok' && !defined $details{$test};

	my ($details) = $details{$test};
	next if !defined ($details) && ! -e "output/$test/run.out";

	print DETAILS "\n" if $n++;
	print DETAILS "--- $test details ", '-' x (50 - length ($test));
	print DETAILS "\n\n";

	if (!defined $details) {
	    $details = "Output:\n\n" . snarf ("output/$test/run.out");
	}
	print DETAILS $details;

	print DETAILS "\n", "-" x 10, "\n\n$extra{$test}"
	    if defined $extra{$test};
    }
    close (DETAILS);

}

sub xsystem {
    my ($command, %options) = @_;
    print "$command\n" if $VERBOSE || $options{VERBOSE};

    my ($log) = $options{LOG};
    if (defined ($log)) {
	$command = "($command) >output/$log.out 2>output/$log.err";
    }

    my ($pid, $status);
    eval {
	local $SIG{ALRM} = sub { die "alarm\n" };
	alarm $options{TIMEOUT} if defined $options{TIMEOUT};
	$pid = fork;
	die "fork: $!\n" if !defined $pid;
	exec ($command), die "$command: exec: $!\n" if !$pid;
	waitpid ($pid, 0);
	$status = $?;
	alarm 0;
    };
    if ($@) {
	die unless $@ eq "alarm\n";   # propagate unexpected errors
	print "Timed out.\n";
	kill SIGTERM, $pid;
	$status = 0;
    }

    if (WIFSIGNALED ($status)) {
	my ($signal) = WTERMSIG ($status);
	die "Interrupted\n" if $signal == SIGINT;
	print "Child terminated with signal $signal\n";
    }

    unlink ("output/$log.err") if defined ($log) && $status == 0;

    die $options{DIE} if $status != 0 && defined $options{DIE};

    return $status == 0;
}

sub snarf {
    my ($file) = @_;
    open (OUTPUT, $file) or die "$file: open: $!\n";
    my (@lines) = <OUTPUT>;
    chomp (@lines);
    close (OUTPUT);
    return wantarray ? @lines : join ('', map ("$_\n", @lines));
}

sub files_equal {
    my ($a, $b) = @_;
    my ($equal);
    open (A, "<$a") or die "$a: open: $!\n";
    open (B, "<$b") or die "$b: open: $!\n";
    if (-s A != -s B) {
	$equal = 0;
    } else {
	my ($sa, $sb);
	for (;;) {
	    sysread (A, $sa, 1024);
	    sysread (B, $sb, 1024);
	    $equal = 0, last if $sa ne $sb;
	    $equal = 1, last if $sa eq '';
	}
    }
    close (A);
    close (B);
    return $equal;
}

sub file_contains {
    my ($file, $expected) = @_;
    open (FILE, "<$file") or die "$file: open: $!\n";
    my ($actual);
    sysread (FILE, $actual, -s FILE);
    my ($equal) = $actual eq $expected;
    close (FILE);
    return $equal;
}

sub number_lines {
    my ($ln, $lines) = @_;
    my ($out);
    for my $line (@$lines) {
	chomp $line;
	$out .= sprintf "%4d  %s\n", $ln++, $line;
    }
    return $out;
}
