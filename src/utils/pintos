#! /usr/bin/perl

$sim = "bochs";
$debug = "";
$mem = 4;
$headless = 0;
while (@ARGV) {
    my ($arg) = shift (@ARGV);
    if ($arg =~ /--(bochs|qemu|gsx)$/) {
	$sim = $1;
    } elsif ($arg =~ /--(monitor|gdb)$/) {
	$debug = $1;
    } elsif ($arg eq 'run') {
	run_vm (@ARGV);
	exit 0;
    } elsif ($arg =~ /^mem(?:ory)?=(\d+)/) {
	$mem = $1;
    } elsif ($arg eq '--headless') {
	$headless = 1;
    } elsif ($arg eq 'make-disk') {
	my ($force) = @ARGV > 0 && $ARGV[0] eq '--force';
	shift @ARGV if $force;
	usage () if @ARGV != 2;
	my ($file, $mb) = @ARGV;
	usage () if $mb !~ /^\d+$/;
	die "$file: already exists\n" if -e $file;

	if ($mb != .5 && $mb != 1 && $mb != 1.5 && $mb != 2) {
	    print "$file: recommended sizes are .5, 1, 1.5, or 2 MB\n";
	    die "use --force to override\n" if !$force;
	}

	create_disk ($file, $mb * 1008);
	exit 0;
    } elsif ($arg eq 'put') {
	usage () if @ARGV != 1 && @ARGV != 2;
	my ($hostfn, $guestfn) = @ARGV;
	$guestfn = $hostfn if !defined $guestfn;

	# Create scratch disk from file.
	die "$hostfn: $!\n" if ! -e $hostfn;
	my ($size) = -s _;
	copy_pad ($hostfn, "scratch.dsk", 512);

	# Do copy.
	run_vm ("-ci", $hostfn, $size, "-q");
	exit 0;
    } elsif ($arg eq 'get') {
	usage () if @ARGV != 1 && @ARGV != 2;
	my ($guestfn, $hostfn) = @ARGV;
	$hostfn = $guestfn if !defined $hostfn;
	die "$hostfn: already exists\n" if -e $file;

	# Create scratch disk big enough for any file in the filesystem
	# (modulo sparse files).
	die "fs.dsk: $!\n" if ! -e "fs.dsk";
	my ($fs_size) = -s _;
	my ($scratch_size) = -s "scratch.dsk";
	$scratch_size = 0 if !defined $scratch_size;
	create_disk ("scratch.dsk", $fs_size / 1024 + 16)
	    if $scratch_size < $fs_size + 16384;

	# Do copy.
	run_vm ("-co", $guestfn, "-q");

	# Read out scratch disk.
	print "copying $guestfn from scratch.dsk to $hostfn...\n";
	open (SRC, "<scratch.dsk") or die "scratch.dsk: open: $!\n";
	open (DST, ">$hostfn") or die "$hostfn: create: $!\n";
	my ($input);
	read (SRC, $input, 512) == 512 or die "scratch.dsk: read error\n";
	my ($size) = unpack ("%V", $input);
	$size != 0xffffffff or die "$guestfn: too big for scratch.dsk?";
	read (SRC, $src, $size) == $size or die "scratch.dsk: read error\n";
	print DST $src or die "$hostfn: write error\n";
	close (DST);
	close (SRC);

	exit 0;
    } else {
	die "unknown option `$arg'\n";
    }
}
usage ();

sub usage {
    my ($exitcode) = @_;
    $exitcode = 1 unless defined $exitcode;
    print "pintos, a utility for invoking Pintos in a simulator\n";
    print "Usage: pintos [OPTION...] COMMAND [ARG...]\n";
    print "where COMMAND is one of the following:\n";
    print "  run [CMDLINE...]        run a VM in the simulator\n";
    print "  make-disk FILE.DSK SIZE create FILE.DSK as empty SIZE MB disk\n";
    print "  put HOSTFN [GUESTFN]    copy HOSTFN into VM (as GUESTFN)\n";
    print "  get GUESTFN [HOSTFN]    copy GUESTFN out of VM (to HOSTFN)\n";
    print "  help                    print this help message and exit\n";
    print "Available options:\n";
    print "  --bochs       Use Bochs as simulator (default)\n";
    print "  --qemu        Use qemu as simulator\n";
    print "  --gsx         Use VMware GSX Server 3.x as simulator\n";
    print "  --monitor     Debug with simulator's monitor\n";
    print "  --gdb	   Debug with gdb\n";
    print "  --mem=MB	   Run VM with MB megabytes of physical memory\n";
    print "  --headless    No VGA display.  Send VM output to stdout\n";
    exit $exitcode;
}

sub copy_pad {
    my ($src, $dst, $blocksize) = @_;
    run_command ("dd", "if=$src", "of=$dst", "bs=$blocksize", "conv=sync");
}

sub create_disk {
    my ($disk, $kb) = @_;
    run_command ("dd", "if=/dev/zero", "of=$disk", "bs=1024", "count=$kb");
}

sub run_vm {
    my (@disks) = (undef, undef, undef, undef);

    $disks[0] = "os.dsk";
    $disks[1] = "fs.dsk" if -e "fs.dsk";
    $disks[2] = "scratch.dsk" if -e "scratch.dsk";
    $disks[3] = "swap.dsk" if -e "swap.dsk";

    die "$disks[0]: can't find OS disk\n" if ! -e $disks[0];
    write_cmd_line ($disks[0], @_);

    if ($sim eq 'bochs') {
	if ($debug eq '') {
	    $bin = 'bochs';
	} elsif ($debug eq 'monitor') {
	    $bin = 'bochs-dbg';
	} elsif ($debug eq 'gdb') {
	    $bin = 'bochs-gdb';
	}
	$bochsbin = search_path ($bin);
	$bochsshare = "$bochsbin/../share/bochs";
	$romimage = "$bochsshare/BIOS-bochs-latest";
	$vgaromimage = "$bochsshare/VGABIOS-lgpl-latest";

	open (BOCHSRC, ">bochsrc.txt") or die "bochsrc.txt: create: $!\n";
	print BOCHSRC "romimage: file=$romimage, address=0xf0000\n";
	print BOCHSRC "vgaromimage: $vgaromimage\n";
	print BOCHSRC bochs_disk_line ("ata0-master", $disks[0]);
	print BOCHSRC bochs_disk_line ("ata0-slave", $disks[1]);
	print BOCHSRC bochs_disk_line ("ata1-master", $disks[2]);
	print BOCHSRC bochs_disk_line ("ata1-slave", $disks[3]);
	print BOCHSRC "boot: c\n";
	print BOCHSRC "ips: 1000000\n";
	print BOCHSRC "clock: sync=none, time0=0\n";
	print BOCHSRC "megs: $mem\n";
	print BOCHSRC "com1: dev=/dev/tty\n" if $headless;
	close (BOCHSRC);
	run_command ($bin, '-q');
    } elsif ($sim eq 'qemu') {
	my (@cmd) = ('qemu');
	push (@cmd, '-hda', $disks[0]) if defined $disks[0];
	push (@cmd, '-hdb', $disks[1]) if defined $disks[1];
	push (@cmd, '-hdc', $disks[2]) if defined $disks[2];
	push (@cmd, '-hdd', $disks[3]) if defined $disks[3];
	push (@cmd, '-m', $mem);
	push (@cmd, '-nographic') if $headless;
	push (@cmd, '-S') if $debug eq 'monitor';
	push (@cmd, '-s') if $debug eq 'gdb';
	run_command (@cmd);
    } elsif ($sim eq 'gsx') {
	print "warning: --$debug not supported by VMware GSX Server, ignoring"
	    if $debug ne '';

	open (VMX, ">pintos.vmx") or die "pintos.vmx: create: $!\n";
	chmod 0777 & ~umask, "pintos.vmx";
	print VMX "#! /usr/bin/vmware -G\n";
	print VMX "config.version = 6\n";
	print VMX "guestOS = \"linux\"\n";
	print VMX "floppy0.present = FALSE\n";

	if (! -e 'null.bin') {
	    open (NULL, ">null.bin") or die "null.bin: create: $!\n";
	    close (NULL);
	}

	for (my ($i) = 0; $i < 4; $i++) {
	    my ($dsk) = $disks[$i];
	    next if !defined $dsk;
	    $device = "ide" . int ($i / 2) . ":" . ($i % 2);

	    my ($pln) = $dsk;
	    $pln =~ s/\.dsk//;
	    $pln .= ".pln";

	    print VMX "\n$device.present = TRUE\n";
	    print VMX "$device.deviceType = \"plainDisk\"\n";
	    print VMX "$device.fileName = \"$pln\"\n";

	    my (%geom) = disk_geometry ($dsk);
	    open (PLN, ">$pln") or die "$pln: create: $!\n";
	    print PLN "DRIVETYPE	ide\n";
	    print PLN "#vm|VERSION	2\n";
	    print PLN "#vm|TOOLSVERSION	2\n";
	    print PLN "CYLINDERS	$geom{C}\n";
	    print PLN "HEADS		$geom{H}\n";
	    print PLN "SECTORS		$geom{S}\n";
	    print PLN "#vm|CAPACITY	$geom{CAPACITY}\n";
	    print PLN "ACCESS \"$dsk\" 0 $geom{CAPACITY}\n";
	    close (PLN);
	}
	close (VMX);

	use Cwd;
	$vmx = getcwd () . "/pintos.vmx";
	system ("vmware-cmd -s register $vmx >&/dev/null");
	system ("vmware-cmd $vmx stop hard >&/dev/null");
	system ("vmware -l -G -x -q $vmx");
	system ("vmware-cmd $vmx stop hard >&/dev/null");
    }
}

sub write_cmd_line {
    my ($disk, @args) = @_;

    die "command line includes empty string" if grep (/^$/, @args);
    $args = join ("\0", @args) . "\0\0";
    die "command line exceeds 128 bytes" if length ($args) > 128;
    $args .= "\0" x (128 - length ($args));

    print "writing command line to $disk...\n";
    open (DISK, "+<$disk") or die "$disk: open: $!\n";
    seek (DISK, 0x17e, 0) or die "$disk: seek: $!\n";
    syswrite (DISK, $args) or die "$disk: write: $!\n";
    close (DISK) or die "$disk: close: $!\n";
}

sub run_command {
    print join (' ', @_), "\n";
    die "command failed\n" if system (@_);
}

sub search_path {
    my ($target) = @_;
    for $dir (split (':', $ENV{PATH})) {
	return $dir if -e "$dir/$target";
    }
    die "$target not in PATH\n";
}

sub bochs_disk_line {
    my ($device, $file) = @_;
    return "" if !defined $file;
    my (%geom) = disk_geometry ($file);
    return "$device: type=disk, path=$file, mode=flat, "
	. " cylinders=$geom{C}, heads=$geom{H}, spt=$geom{S}, "
	. "translation=none\n";
}

sub disk_geometry {
    my ($file) = @_;
    my ($size) = -s $file;
    die "$file: stat: $!\n" if !defined $size;
    die "$file: size not a multiple of 512 bytes\n" if $size % 512;
    $cylinders = int ($size / (512 * 16 * 63));
    $cylinders++ if $size % (512 * 16 * 63);

    return (CAPACITY => $size / 512,
	    C => $cylinders,
	    H => 16,
	    S => 63);
}
