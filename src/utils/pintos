#! /usr/bin/perl -w

use strict;
use POSIX;

our ($mem) = 4;
our ($serial_out) = 1;
our (@disks) = ("os.dsk", "fs.dsk", "scratch.dsk", "swap.dsk");
our ($sim);
our ($debug);
our ($vga);
our ($jitter, $realtime);

use Getopt::Long qw(:config require_order bundling);
unshift (@ARGV, split (' ', $ENV{PINTOSOPTS}))
    if defined $ENV{PINTOSOPTS};
GetOptions ("sim=s" => sub { set_sim (@_) },
	    "bochs" => sub { set_sim ("bochs") },
	    "qemu" => sub { set_sim ("qemu") },
	    "gsx" => sub { set_sim ("gsx") },

	    "debug=s" => sub { set_debug (@_) },
	    "no-debug" => sub { set_debug ("no-debug") },
	    "monitor" => sub { set_debug ("monitor") },
	    "gdb" => sub { set_debug ("gdb") },

	    "run|get|put|make-disk" => \&cmd_option,

	    "m|memory=i" => \$mem,
	    "j|jitter=i" => sub { set_jitter (@_) },
	    "r|realtime" => sub { set_realtime () },

	    "v|no-vga" => sub { set_vga ('none'); },
	    "s|no-serial" => sub { $serial_out = 0; },
	    "t|terminal" => sub { set_vga ('terminal'); },

	    "h|help" => sub { usage (0); },

	    "0|os-disk|disk-0|hda=s" => \$disks[0],
	    "1|fs-disk|disk-1|hdb=s" => \$disks[1],
	    "2|scratch-disk|disk-2|hdc=s" => \$disks[2],
	    "3|swap-disk|disk-3|hdd=s" => \$disks[3])
    or exit 1;

$sim = "bochs" if !defined $sim;
$debug = "no-debug" if !defined $debug;
$vga = "window" if !defined $vga;

sub set_sim {
    my ($new_sim) = @_;
    die "--$new_sim conflicts with --$sim\n"
	if defined ($sim) && $sim ne $new_sim;
    $sim = $new_sim;
}

sub set_debug {
    my ($new_debug) = @_;
    die "--$new_debug conflicts with --$debug\n"
	if defined ($debug) && $debug ne $new_debug;
    $debug = $new_debug;
}

sub set_vga {
    my ($new_vga) = @_;
    if (defined ($vga) && $vga ne $new_vga) {
	print "warning: conflicting vga display options\n";
    }
    $vga = $new_vga;
}

sub set_jitter {
    my ($new_jitter) = @_;
    die "--realtime conflicts with --jitter\n" if defined $realtime;
    die "different --jitter already defined\n"
	if defined $jitter && $jitter != $new_jitter;
    $jitter = $new_jitter;
}

sub set_realtime {
    die "--realtime conflicts with --jitter\n" if defined $jitter;
    $realtime = 1;
}

sub cmd_option {
    # Force an end to option processing, as with --.
    die ("!FINISH");
}

die "no command specified; use --help for help\n"
    if @ARGV < 1;
my ($cmd) = shift @ARGV;
if ($cmd eq 'run') {
    run_vm (@ARGV);
} elsif ($cmd eq 'make-disk') {
    usage () if @ARGV != 2;
    my ($file, $mb) = @ARGV;
    usage () if $mb !~ /^\d+(\.\d+)?|\.\d+$/;
    die "$file: already exists\n" if -e $file;

    create_disk ($file, int ($mb * 1008));
} elsif ($cmd eq 'put') {
    # Take a -f option to combine formatting with putting.
    my ($format) = 0;
    if (@ARGV > 0 && $ARGV[0] eq '-f') {
	shift @ARGV;
	$format = 1;
    }

    usage () if @ARGV != 1 && @ARGV != 2;
    my ($hostfn, $guestfn) = @ARGV;
    $guestfn = $hostfn if !defined $guestfn;

    # Create scratch disk from file.
    die "$hostfn: $!\n" if ! -e $hostfn;
    my ($size) = -s _;
    if ($size) {
	copy_pad ($hostfn, "scratch.dsk", 512);
    } else {
	open (SCRATCH, ">scratch.dsk") or die "scratch.dsk: create: $!\n";
	syswrite (SCRATCH, "\0" x 512);
	close (SCRATCH);
    }

    # Do copy.
    my (@cmd) = ("-ci", $guestfn, $size, "-q");
    unshift (@cmd, "-f") if $format;
    run_vm (@cmd);
} elsif ($cmd eq 'get') {
    usage () if @ARGV != 1 && @ARGV != 2;
    my ($guestfn, $hostfn) = @ARGV;
    $hostfn = $guestfn if !defined $hostfn;
    die "$hostfn: already exists\n" if -e $hostfn;

    # Create scratch disk big enough for any file in the filesystem
    # (modulo sparse files).
    die "$disks[1]: $!\n" if ! -e $disks[1];
    my ($fs_size) = -s _;
    my ($scratch_size) = -s $disks[2];
    $scratch_size = 0 if !defined $scratch_size;
    create_disk ($disks[2], $fs_size / 1024 + 16)
	if $scratch_size < $fs_size + 16384;

    # Do copy.
    run_vm ("-co", $guestfn, "-q");

    # Read out scratch disk.
    print "copying $guestfn from $disks[2] to $hostfn...\n";
    open (SRC, "<$disks[2]") or die "$disks[2]: open: $!\n";
    open (DST, ">$hostfn") or die "$hostfn: create: $!\n";
    my ($input);
    read (SRC, $input, 512) == 512 or die "$disks[2]: read error\n";
    my ($size) = unpack ("V", $input);
    $size != 0xffffffff or die "$guestfn: too big for $disks[2]?";
    my ($src);
    read (SRC, $src, $size) == $size or die "$disks[2]: read error\n";
    print DST $src or die "$hostfn: write error\n";
    close (DST);
    close (SRC);
} elsif ($cmd eq 'help') {
    usage (0);
} else {
    die "unknown command `$cmd'; use --help for help\n";
}
exit 0;

sub usage {
    my ($exitcode) = @_;
    $exitcode = 1 unless defined $exitcode;
    print "pintos, a utility for invoking Pintos in a simulator\n";
    print "Usage: pintos [OPTION...] COMMAND [ARG...]\n";
    print "where COMMAND is one of the following:\n";
    print "  run [CMDLINE...]        run a VM in the simulator\n";
    print "  make-disk FILE.DSK SIZE create FILE.DSK as empty SIZE MB disk\n";
    print "  put HOSTFN [GUESTFN]    copy HOSTFN into VM (as GUESTFN)\n";
    print "  get GUESTFN [HOSTFN]    copy GUESTFN out of VM (to HOSTFN)\n";
    print "  help                    print this help message and exit\n";
    print "Simulator options:\n";
    print "  --bochs          (default) Use Bochs as simulator\n";
    print "  --qemu           Use qemu as simulator\n";
    print "  --gsx            Use VMware GSX Server 3.x as simulator\n";
    print "Debugger options:\n";
    print "  --no-debug       (default) No debugger\n";
    print "  --monitor        Debug with simulator's monitor\n";
    print "  --gdb            Debug with gdb\n";
    print "Display options: (default is VGA + serial)\n";
    print "  -v, --no-vga     No VGA display\n";
    print "  -s, --no-serial  No serial output\n";
    print "  -t, --terminal   Display VGA in terminal (Bochs only)\n";
    print "VM options:\n";
    print "  -j SEED          Randomize timer interrupts (Bochs only)\n";
    print "  -r, --realtime   Use realistic, but not reproducible, timings\n";
    print "  -m, --mem=MB     Run VM with MB megabytes of physical memory\n";
    print "Disk options:\n";
    print "  --os-disk=DISK    Set OS disk file (default: os.dsk)\n";
    print "  --fs-disk=DISK    Set FS disk file (default: fs.dsk)\n";
    print "  --scratch-disk=DISK   Set scratch disk (default: scratch.dsk)\n";
    print "  --swap-disk=DISK  Set swap disk file (default: swap.dsk)\n";
    exit $exitcode;
}

sub copy_pad {
    my ($src, $dst, $blocksize) = @_;
    run_command ("dd", "if=$src", "of=$dst", "bs=$blocksize", "conv=sync");
}

sub create_disk {
    my ($disk, $kb) = @_;
    run_command ("dd", "if=/dev/zero", "of=$disk", "bs=1024", "count=$kb");
}

sub run_vm {
    my (@args) = @_;

    our (@disks);

    die "$disks[0]: can't find OS disk\n" if ! -e $disks[0];
    die "$disks[0]: OS disk cannot have zero size\n" if ! -s $disks[0];
    for my $i (1...3) {
	undef $disks[$i] if ! -s $disks[$i];
    }

    if (my ($project) = `pwd` =~ /\b(threads|userprog|vm|filesys)\b/) {
	if ((grep ($project eq $_, qw (userprog vm filesys)))
	    && !defined ($disks[1])) {
	    print STDERR "warning: it looks like you're running the $project ";
	    print STDERR "project, but no file system disk is present\n";
	}
	if ($project eq 'vm' && !defined $disks[3]) {
	    print STDERR "warning: it looks like you're running the $project ";
	    print STDERR "project, but no swap disk is present\n";
	}
    }

    write_cmd_line ($disks[0], @args);

    if ($sim eq 'bochs') {
	my ($bin);
	if ($debug eq 'no-debug') {
	    $bin = 'bochs';
	} elsif ($debug eq 'monitor') {
	    $bin = 'bochs-dbg';
	} elsif ($debug eq 'gdb') {
	    $bin = 'bochs-gdb';
	}

	my ($bochsbin) = search_path ($bin);
	my ($bochsshare) = "$bochsbin/../share/bochs";

	open (BOCHSRC, ">bochsrc.txt") or die "bochsrc.txt: create: $!\n";
	print BOCHSRC "romimage: file=$bochsshare/BIOS-bochs-latest, "
	    . "address=0xf0000\n";
	print BOCHSRC "vgaromimage: $bochsshare/VGABIOS-lgpl-latest\n";
	print BOCHSRC bochs_disk_line ("ata0-master", $disks[0]);
	print BOCHSRC bochs_disk_line ("ata0-slave", $disks[1]);
	print BOCHSRC "ata1: enabled=1, ioaddr1=0x170, ioaddr2=0x370, irq=15\n"
	    if defined ($disks[2]) || defined ($disks[3]);
	print BOCHSRC bochs_disk_line ("ata1-master", $disks[2]);
	print BOCHSRC bochs_disk_line ("ata1-slave", $disks[3]);
	print BOCHSRC "boot: c\n";
	print BOCHSRC "ips: 1000000\n";
	if (!$realtime) {
	    print BOCHSRC "clock: sync=none, time0=0\n";
	} else {
	    print BOCHSRC "clock: sync=realtime, time0=0\n";
	}
	print BOCHSRC "megs: $mem\n";
	print BOCHSRC "log: bochsout.txt\n";
	if ($vga ne 'terminal') {
	    print BOCHSRC "com1: enabled=1, dev=/dev/stdout\n"
		if $serial_out;
	    print BOCHSRC "display_library: nogui\n"
		if $vga eq 'none';
	} else {
	    print BOCHSRC "display_library: term\n";
	}
	close (BOCHSRC);

	my (@cmd) = ($bin, '-q');
	push (@cmd, '-j', $jitter) if defined $jitter;
	print join (' ', @cmd), "\n";
	my ($exit) = xsystem (@cmd);
	if (WIFEXITED ($exit)) {
	    # Bochs exited normally.
	    # Ignore the exit code; Bochs normally exits with status 1,
	    # which is weird.
	} elsif (WIFSIGNALED ($exit)) {
	    die "Bochs died with signal ", WTERMSIG ($exit), "\n";
	} else {
	    die "Bochs died: code $exit\n";
	}
    } elsif ($sim eq 'qemu') {
	print "warning: qemu doesn't support --terminal\n"
	    if $vga eq 'terminal';
	print "warning: qemu doesn't support jitter\n"
	    if defined $jitter;
	my (@cmd) = ('qemu');
	push (@cmd, '-hda', $disks[0]) if defined $disks[0];
	push (@cmd, '-hdb', $disks[1]) if defined $disks[1];
	push (@cmd, '-hdc', $disks[2]) if defined $disks[2];
	push (@cmd, '-hdd', $disks[3]) if defined $disks[3];
	push (@cmd, '-m', $mem);
	push (@cmd, '-nographic') if $vga eq 'none';
	push (@cmd, '-serial', 'stdio') if $serial_out && $vga ne 'none';
	push (@cmd, '-S') if $debug eq 'monitor';
	push (@cmd, '-s') if $debug eq 'gdb';
	run_command (@cmd);
    } elsif ($sim eq 'gsx') {
	print "warning: VMware GSX Server doesn't support --$debug\n"
	    if $debug ne 'no-debug';
	print "warning: VMware GSX Server doesn't support --no-vga\n"
	    if $vga eq 'none';
	print "warning: VMware GSX Server doesn't support --terminal\n"
	    if $vga eq 'terminal';
	print "warning: VMware GSX Server doesn't support jitter\n"
	    if defined $jitter;

	open (VMX, ">pintos.vmx") or die "pintos.vmx: create: $!\n";
	chmod 0777 & ~umask, "pintos.vmx";
	print VMX "#! /usr/bin/vmware -G\n";
	print VMX "config.version = 6\n";
	print VMX "guestOS = \"linux\"\n";
	print VMX "floppy0.present = FALSE\n";

	unlink ("pintos.out");
	print VMX "serial0.present = TRUE\n";
	print VMX "serial0.fileType = \"file\"\n";
	print VMX "serial0.fileName = \"pintos.out\"\n";

	if (! -e 'null.bin') {
	    open (NULL, ">null.bin") or die "null.bin: create: $!\n";
	    close (NULL);
	}

	for (my ($i) = 0; $i < 4; $i++) {
	    my ($dsk) = $disks[$i];
	    next if !defined $dsk;

	    my ($pln) = $dsk;
	    $pln =~ s/\.dsk//;
	    $pln .= ".pln";

	    my ($device) = "ide" . int ($i / 2) . ":" . ($i % 2);
	    print VMX "\n$device.present = TRUE\n";
	    print VMX "$device.deviceType = \"plainDisk\"\n";
	    print VMX "$device.fileName = \"$pln\"\n";

	    my (%geom) = disk_geometry ($dsk);
	    open (PLN, ">$pln") or die "$pln: create: $!\n";
	    print PLN "DRIVETYPE	ide\n";
	    print PLN "#vm|VERSION	2\n";
	    print PLN "#vm|TOOLSVERSION	2\n";
	    print PLN "CYLINDERS	$geom{C}\n";
	    print PLN "HEADS		$geom{H}\n";
	    print PLN "SECTORS		$geom{S}\n";
	    print PLN "#vm|CAPACITY	$geom{CAPACITY}\n";
	    print PLN "ACCESS \"$dsk\" 0 $geom{CAPACITY}\n";
	    close (PLN);
	}
	close (VMX);

	my ($vmx) = getcwd () . "/pintos.vmx";
	system ("vmware-cmd -s register $vmx >&/dev/null");
	system ("vmware-cmd $vmx stop hard >&/dev/null");
	system ("vmware -l -G -x -q $vmx");
	system ("vmware-cmd $vmx stop hard >&/dev/null");
    }
}

sub relay_signal {
    my ($pid, $signal) = @_;
    kill $signal, $pid;
    $SIG{$signal} = 'DEFAULT';
    kill $signal, getpid ();
}

sub xsystem {
    my ($pid) = fork;
    if (!defined ($pid)) {
	# Fork failed.
	die "fork: $!\n";
    } elsif (!$pid) {
	# Running in child process.
	exec (@_);
	exit (1);
    } else {
	# Running in parent process.
	local $SIG{INT} = sub { relay_signal ($pid, "INT"); };
	local $SIG{TERM} = sub { relay_signal ($pid, "TERM"); };
	waitpid ($pid, 0);
	return $?;
    }
}

sub write_cmd_line {
    my ($disk, @args) = @_;

    die "command line includes empty string" if grep (/^$/, @args);
    my ($args) = join ("\0", @args) . "\0\0";
    die "command line exceeds 128 bytes" if length ($args) > 128;
    $args .= "\0" x (128 - length ($args));

    print "writing command line to $disk...\n";
    open (DISK, "+<$disk") or die "$disk: open: $!\n";
    seek (DISK, 0x17e, 0) or die "$disk: seek: $!\n";
    syswrite (DISK, $args) or die "$disk: write: $!\n";
    close (DISK) or die "$disk: close: $!\n";
}

sub run_command {
    print join (' ', @_), "\n";
    die "command failed\n" if xsystem (@_);
}

sub search_path {
    my ($target) = @_;
    for my $dir (split (':', $ENV{PATH})) {
	return $dir if -e "$dir/$target";
    }
    die "$target not in PATH\n";
}

sub bochs_disk_line {
    my ($device, $file) = @_;
    return "" if !defined $file;
    my (%geom) = disk_geometry ($file);
    return "$device: type=disk, path=$file, mode=flat, "
	. "cylinders=$geom{C}, heads=$geom{H}, spt=$geom{S}, "
	. "translation=none\n";
}

sub disk_geometry {
    my ($file) = @_;
    my ($size) = -s $file;
    die "$file: stat: $!\n" if !defined $size;
    die "$file: size not a multiple of 512 bytes\n" if $size % 512;
    my ($cylinders) = int ($size / (512 * 16 * 63));
    $cylinders++ if $size % (512 * 16 * 63);

    return (CAPACITY => $size / 512,
	    C => $cylinders,
	    H => 16,
	    S => 63);
}
